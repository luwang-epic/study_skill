package com.wang;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/*
认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。
认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，
不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式

用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。
会话就是系统为了保持当前用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。
如今移动互联网时代更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。

基于session的会话:
    基于session的认证方式如下图： 它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，
    发给客户端的 sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在
    session 数据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。
基于token的会话：
    基于token方式如下图： 它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端存储token，
    每次请求时带上token，服务端收到token通过验证后即可确认用户。


授权： 授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问。
认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的， 控制不同的用户能够访问不同的资源。


分布式环境：
    1、基于session的认证方式
        在分布式的环境下，基于session的认证会出现一个问题，每个应用服务都需要在session中存储用户身份信息，
        通过负载均衡将本地的请求分配到另一个应用服务需要将session信息带过去，否则会重新认证。这个时候，通常的做法有下面几种：
            Session复制	多台应用服务器之间同步session，使session保持一致，对外透明。
            Session黏贴	当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上。
            Session集中存储	将Session存入分布式缓存中，所有服务器应用实例统一从分布式缓存中存取Session。
        总体来讲，基于session认证的认证方式，可以更好的在服务端对会话进行控制，且安全性较高。
        但是，session机制方式基于cookie，在复杂多样的移动客户端上不能有效的使用，并且无法跨域，
        另外随着系统的扩展需提高session的复制、黏贴及存储的容错性。
    2、基于token的认证方式
        基于token的认证方式，服务端不用存储认证数据，易维护扩展性强，
        客户端可以把token 存在任意地方，并且可以实现web和app统一认证机制。
        其缺点也很明显，token由于自包含信息，因此一般数据量较大，而且每次请求都需要传递，因此比较占带宽。
        另外，token的签名验签操作也会给cpu带来额外的处理负担。

基于token的认证方式相比传统的session认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下：
    支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题
    无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力
    更适用CDN：可以通过内容分发网络请求服务端的所有资料
    更适用于移动端：当客户端是非浏览器平台时，cookie是不被支持的，此时采用token认证方式会简单很多
    无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御


token认证方式对第三方应用接入更适合，因为它更开放，使用当前有流行的开放协议Oauth2.0（基于JWT的）
    Oauth2:
        Oauth2协议是一个授权协议，它允许软件应用代表（而不是充当）资源拥有者去访问资源拥有者的资源。
        应用向资源拥有者请求授权，然后获得令牌（token），并用它来访问资源，并且资源拥有者不同向应用提供用户名和密码等敏感数据

        授权流程：
            1. 在开放接口平台申请一个appId（应用id）和appPassword（秘钥）
            2. 通过appId和appPassword调用开放接口平台接口获取token （临时且唯一的，具有过期时间，过期可以刷新token）
            3. 再使用token调用接口

        主要应用场景：
            第三方联合登录（使用第三方账号登录），比如QQ联合登录
            开发接口， 比如开发openapi，腾讯的一些开发接口认证

            如：使用微信登录
                1. 在需要用户登录时，生成一个微信连接，传入appId和一个回调地址 （地址格式是开放平台指定的，这里是微信）
                2. 当用户微信打开该地址时（对于微信，一般将地址生成二维码，用户扫描即可打开），会出现是否同意授权页面
                3. 当用户点击确认授权，会重定向到提供的回调地址（回调地址类似http://localhost:8080?code=xxx）形式，
                    应用可以拿到微信返回的code信息
                4. 使用code以及appId，appPassword调用微信接口获取访问token（同时也会返回该用户对该应用的唯一id（openid））
                5. 使用返回的token + openapi可以调用微信的接口获取用户已经授权的基本信息
    JWT:
        JWT的本质就是一个字符串，它是将用户信息保存到一个Json字符串中，然后进行编码后得到一个JWT token，
        并且这个JWT token带有签名信息，接收后可以校验是否被篡改，所以可以用于在各方之间安全地将信息作为Json对象传输。

 */

@SpringBootApplication
public class StudySpringSecurityApplication {

    public static void main(String[] args) {
        SpringApplication.run(StudySpringSecurityApplication.class, args);
    }

}