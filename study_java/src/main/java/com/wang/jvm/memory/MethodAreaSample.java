package com.wang.jvm.memory;

import org.junit.jupiter.api.Test;


/*
方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。
方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的（逻辑上连续，物理上可以不连续）。
方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。

在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。
JDK8终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存

它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
    1. 类信息：对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
        这个类型的完整有效名称（全名=包名.类名）
        这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）
        这个类型的修饰符（public，abstract，final的某个子集）
        这个类型直接接口的一个有序列表
    2. 域（Field）信息：JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
        域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）
    3. 方法（Method）信息：JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：
        方法名称
        方法的返回类型（或 void ）
        方法参数的数量和类型（按顺序）
        方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
        方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
        异常表（abstract和native方法除外）（如果方法有异常）
            每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
    4. Non-Final的类变量（即static的变量）
        静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
    5. 全局常量：就是使用static final进行修饰的，每个全局常量在编译的时候就会被分配了
        这里需要注意：jdk7之后全局常量会存放在方法区中，但是全局常量的实例会存放在堆中（即new出来的部分）
    6. 运行时常量池：字节码文件内部包含了常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型，
        方法区内部包含了运行时常量池，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
        JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
        运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。
        此时不再是常量池中的符号地址了，这里换为真实地址。
        运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性，即：运行时也可以访问新的常量。

        StringTable为什么要调整位置（String类型的常量，在jdk7之后放到了堆中）
            JDK 7 中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会触发。
            而Full GC是老年代的空间不足、永久代不足时才会触发。这就导致 StringTable 回收效率不高。
            而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。


方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。也会对无用的类加载器进行回收
    HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。
    判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
        1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
        2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，
            如 OSGi、JSP的重加载等，否则通常是很难达成的。
        3. 该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，
通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

 */
/**
 * 方法区
 *  jdk8叫元空间，之前加永久代
 */
public class MethodAreaSample {


    @Test
    public void ClassStaticMethodAccess() {
        Order order = null;
        // 静态方法和变量访问不需要实例，因此这里即使不初始化，也不会抛异常，可以正常访问
        order.hello();
        System.out.println(order.count);
    }

    private static class Order {
        public static int count = 1;
        public static final int number = 2;
        public static void hello() {
            System.out.println("hello!");
        }
    }
}
