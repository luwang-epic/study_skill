package com.wang.jvm.garbage;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Scanner;

/*
相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，
更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

基本思路：可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

Java 中 GC Roots 可以是哪些？
    1. 虚拟机栈中引用的对象；比如：各个线程被调用的方法中使用到的参数、局部变量等。
    2. 本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象；比如：类常量实例，字符串常量池（String Table）里的引用
    4. 所有被同步锁 synchronized 持有的对象
    5. Java虚拟机内部的引用。
    6. 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。
    7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。
这点不满足的话分析结果的准确性就无法保证。这点也是导致 GC 进行时必须“Stop The World”的一个重要原因。
即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。

一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，
为此，定义虚拟机中的对象可能的三种状态。如下：
    1. 可触及的：从根节点开始，可以到达这个对象。
    2. 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活。
    3. 不可触及的：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。
        不可触及的对象不可能被复活，因为finalize()只会被调用一次。

只有在对象不可触及时才可以被回收。判定一个对象 objA 是否可回收，至少要经历两次标记过程：
    1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。
    2. 进行筛选，判断此对象是否有必要执行finalize()方法
    3. 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，
        则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。
    4. 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，
        由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。
    5. finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。
        如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，
        objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。
        在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，
        也就是说，一个对象的finalize()方法只会被调用一次。

目前在 JVM 中比较常见的三种垃圾收集算法是
    1. 标记一清除算法（Mark-Sweep）
        标记：Collector从引用根节点开始遍历，标记所有被引用的对象。
            一般是在对象的Header中记录为可达对象。标记的是引用的对象，不是垃圾！！
        清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收
    2. 复制算法（Copying）
        将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，
        之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
    3. 标记-压缩算法（Mark-Compact）
        第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
        第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

        标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，
        因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。

    	    标记清除	            标记整理	            复制
速率	        中等	                最慢	                最快
空间开销	    少（但会堆积碎片）	    少（不堆积碎片）	    通常需要活对象的2倍空间（不堆积碎片）
移动对象	    否	                是	                是

其他垃圾回收算法：
分代收集算法:
    分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。
    因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
    一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
    目前几乎所有的GC都采用分代收集算法执行垃圾回收的
增量收集算法：
    如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。
    每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
    总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。

    增量收集算法通过对线程间冲突的妥善处理允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作
    使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。
    但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。
分区算法（G1垃圾回收器）：
    一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。
    为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，
    每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。

    分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。
     每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

Stop-The-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。
停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。
STW事件和采用哪款GC无关，所有的GC都有这个事件。

垃圾回收的并行与并发
    并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
        如 ParNew、Parallel Scavenge、Parallel Old；
    并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），
        垃圾回收线程在执行时不会停顿用户程序的运行。如：CMS、G1
        此时用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上

程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（SafePoint）”。
SafePoint的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。
大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。
比如：选择一些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等。
如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？
    抢先式中断（目前没有虚拟机采用了）：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
    主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，
        如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。
我们也可以把 Safe Region 看做是被扩展了的 SafePoint。可以解决线程睡眠等待情况下的GC安全点选择

7种经典的垃圾收集器
    串行回收器：Serial、Serial Old
    并行回收器：ParNew、Parallel Scavenge、Parallel Old
    并发回收器：CMS、G1

    新生代收集器：Serial、ParNew、Parallel Scavenge；
    老年代收集器：Serial Old、Parallel Old、CMS；
    整堆收集器：G1；

可以搭配使用（格式：新生代/老年代）：Serial/Serial Old、Serial/CMS、
ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、
Parallel Scavenge/Parallel Old、G1/G1
(其中Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案。)

Serial收集器作为HotSpot中 Client模式下的默认新生代垃圾收集器。
Serial 收集器采用复制算法、串行回收和"Stop-The-World"机制的方式执行内存回收。

除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。
Serial Old 收集器同样也采用了串行回收和"Stop The World"机制，只不过内存回收算法使用的是标记-压缩算法。
    Serial Old是运行在Client模式下默认的老年代的垃圾回收器
    Serial Old在Server模式下主要有两个用途：
        与新生代的Parallel Scavenge配合使用
        作为老年代CMS收集器的后备垃圾收集方案

如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。(Par是Parallel的缩写，New：只能处理的是新生代)
ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。
ParNew收集器在年轻代中同样也是采用复制算法、"Stop-The-World"机制。

HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，
Parallel Scavenge收集器同样也采用了复制算法、并行回收和"Stop The World"机制。在Java8中，默认是此垃圾收集器。
Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和"Stop-The-World"机制。
和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），
它也被称为吞吐量优先的垃圾收集器。自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。
高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。

CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，
它第一次实现了让垃圾收集线程与用户线程同时工作。CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间
CMS 的垃圾收集算法采用标记-清除算法，并且也会"Stop-The-World"
CMS 整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。
(涉及STW的阶段主要是：初始标记 和 重新标记)
要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，
这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。
CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，
由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。
那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，
而只能够选择空闲列表（Free List）执行内存分配。那么CMS为什么不使用标记整理(压缩)算法？
答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？
要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact更适合“Stop The World” 这种场景下使用

G1（Garbage-First是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，
以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。与其他GC收集器相比，G1使用了全新的分区算法
因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。
使用不同的Region来表示 Eden、幸存者0区，幸存者1区，老年代等。
G1 GC 有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小，
回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
G1有如下的有点：
1.并发与并行：
    并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程 STW
    并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，
        一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
2.分代收集
    将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代
    也就是分别将年轻代（包括S1,S2区）和老年代划分成很多区域，它同时兼顾年轻代和老年代的垃圾回收
3.空间整合
    G1将内存划分为一个个的 Region。内存的回收是以Region作为基本单位的。Region 之间是复制算法，
    但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。
    这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。
    尤其是当 Java 堆非常大的时候，G1的优势更加明显。
4.可预测的停顿时间模型
    这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，
    能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
        由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，
            因此对于全局停顿情况的发生也能得到较好的控制。
        G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），
            在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region 。
            保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
        相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。
G1的缺点：相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，
    G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。
从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB 之间。
G1收集器的适用场景：面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）
    最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案

ZGC垃圾回收器在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。
使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。
ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。
ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。

 */

/**
 * 垃圾回收相关的概念
 */
public class GarbageCollectionSample {

    public static void main(String[] args) {
        List<Object> numList = new ArrayList<>();
        Date birth = new Date();

        for (int i = 0; i < 100; i++) {
            numList.add(String.valueOf(i));
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("数据添加完毕，请操作：");
        new Scanner(System.in).next();
        numList = null;
        birth = null;

        System.out.println("numList、birth已置空，请操作：");
        new Scanner(System.in).next();

        System.out.println("结束");
    }
}
