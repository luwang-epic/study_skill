package com.wang.jvm.execution;


/*
执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。
简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。

执行引擎的工作流程
    执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。
    每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
    当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，
        以及通过对象头中的元数据指针定位到目标对象的类型信息。

当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。
完成这个过程的程序就叫做解释程序或编译程序。（解释器是边翻译边执行，编译器时先将代码都编译好，然后再执行）
高级语言也不是直接翻译成机器指令，而是翻译成汇编语言，包括C++，JAVA等所有高级语言

执行引擎主要包括：解释器（Interpreter），JIT编译器（Just In Time Compiler），垃圾回收器（GC）
1. 解释器（Interpreter）
    当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，
    将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
    当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。
    编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
2. JIT编译器
    就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。
    翻译成本地代码后，就可以做一个缓存操作，存储在方法区中
    即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，
    只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。

现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。所以说Java是半编译半解释型语言

HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。
在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，
尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
在此共存的模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，
这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，
获得更高的执行效率。同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的备用方案。

当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。
关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，
将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，
通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：
    -Xint：完全采用解释器模式执行程序
    -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
    -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。

在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，
但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器
    -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
        C1 编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
    -server：指定Java虚拟机运行在Server模式下，并使用C2编译器。64位系统只能使用server模式
        C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++实现）

 */
/**
 * 执行引擎
 */
public class ExecutionEngineSample {

    /*
    测试解释器模式和JIT编译模式的执行时间
        通过调整jvm参数来运行下面的main方法，参数分别为：-Xint -Xcomp -Xmixed（默认）
     */
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        testPrimeNumber(100 * 10000);
        long end = System.currentTimeMillis();

        System.out.println("花费的诗句为：" + (end - start));
    }

    public static void testPrimeNumber(int count) {
        for (int i = 0; i < count; i++) {
            // 计算100以内的质数
            label:
            for (int j = 2; j <= 100; j++) {
                for (int k = 2; k <= Math.sqrt(j); k++) {
                    if (j % k == 0) {
                        continue label;
                    }
                }
            }
        }
    }

}
